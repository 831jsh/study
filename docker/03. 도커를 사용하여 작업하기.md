### 첫 번째 컨테이너 구축

```
$ sudo docker run -i -t ubuntu /bin/bash
```

먼저 도커는 docker run을 입력해서 커맨드를 실행한다. 두 개의 커맨드 라인 프랠그를 넘기는데 하나는 -i이고 다른 하나는 -t이다. -i플래그는 컨테이너에 STDIN을 연결하지 않았음에도 불구하고 컨테이너가 STDIN오픈을 해서 유지하도록 한다. -t플래그는 도커에서 생성한 컨테이너에 tty를 할당하도록 한다. 이것은 새로운 컨테이너에서 인터랙티브 쉘을 사용할 수 있도록 해준다. 이 라인은 컨테이너를 생성하기 위해 필요한 기본 설정이며 컨테이너를 데몬 서비스로 실행하기보다는 커맨드 라인에서 인터랙티브하게 사용하고 싶을 때 사용하는 명령어다.

다음으로 컨테이너를 생성하기 위해 어떤 이미지를 사용할지 도커에게 알려줘야 한다. 여기서 백그라운드에서는 어떤 일들이 일어나고 있을까? 먼저 도커가 우분투 이미지를 로컬에서 체크하낟. 로컬 도커 호스트에서 이미지를 찾지 못하면 Docker Inc에 의해 실행되는 Docker Hub 레지스트레에 연결하여 이곳에서 해당 이미지를 찾는다. 도커가 이미지를 찾게 되면 이미지를 다운로드하여 로컬 호스트에 저장한다. 

그리고 나서 도커는 이 이미지를 사용하여 파일 시스템에 새로운 컨테이너를 생성한다. 이 컨테이너는 네트워크, IP주소, 그리고 로컬 호스트와 통신할 브릿지 인터페이스를 가지고 있다. 마지막으로 도커에서 어떤 커맨드를 새로운 컨테이너에 실행할지 알려준다. 이 경우에는 /bin/bash 커맨드를 사용하여 Bash 쉘을 런칭한다. 

###  첫 번째 컨테이너로 작업하기 

이제 새로운 컨테이너에 로그인을 해보자. xxxxxx라는 ID를 사용하며 루트 유저다. 이렇게 로그인을 하면 완전한 우분투 호스트가 되며 이 안에서 우분투 쉘에서 하는 것들을 대부분 할 수 있다. 

```
root@f7cbac22a02:/# hostname
f7cbac22a02
```

컨테이너의 호스트 이름이 컨테이너 ID라는 것을 할 수 있다. /etc/hosts 파일도 살펴보자 

```
root@f7cbac22a02:/# cat /etc/hosts
172.17.0.4 f7cbac22a02
```

도커는 IP주소를 갖는 컨테이너를 위해 호스트 엔트리도 추가했다. 네트워크 설정도 체크해보자 

```
root@f7cbac22a02:/# ip a
lo: <LOOPBACK...>
      127.0.0.1 ...
      ...
      
eth0: <BROADCAST...>
      172.17.0.4 ...
      ...
```

살펴본 대로 다른 호스트처럼 lo루프백 인터페이스와 IP주소가 172.17.0.4인 표준 eth 네트워크 인터페이스를 갖고 있다. 

실행되고 있는 프로세스도 체크할 수 있다. 

```
root@f7cbac22a02:/# ps -aux
```

작업을 끝내면 exit를 입력하고 우분투 호스트의 커맨드 프롬프트로 되돌아간다. 
그렇다면 컨테이너에서 무슨 일이 일어난 것일까? 현재 실행이 중지됐다. 컨테이너는 우리가 설정한 커맨드인 /bin/bash가 실행 중인 동안에만 실행할 수 있다. 컨테이너에서 빠져나오면 커맨드도 끝나고 컨테이너는 중지된다.

도커는 여전히 존재한다. docker ps -a커맨드를 사용하여 현재 컨테이너의 리스트를 볼 수 있다. 
기본적으로 docker ps를 실행하면 실행되고 있는 컨테이너를 확인할 수 있다. docker ps 커맨드를 사용할 때 -a 플래그를 함께 사용하면 중지됐거나 실행 중인 모든 컨테이너를 보여준다.  docker ps -l을 사용하면 실행 중이든 중지든 가장 최근에 실행했던 컨테이너를 보여준다. 

컨테이너에 대한 약간의 정보를 알 수 있다. 이 정보는 컨테이너 ID, 생성하기 위해 사용한 이미지, 마짐가으로 실행한 커맨드, 컨테이너가 생성된 시간 그리고 컨테이너가 종료됐을 때의 상태(0이면 정상 종료), 또한 각 컨테이너의 이름도 볼 수 있다. 

