###첫 번째 컨테이너 구축

```
$ sudo docker run -i -t ubuntu /bin/bash
```

먼저 도커는 docker run을 입력해서 커맨드를 실행한다. 두 개의 커맨드 라인 프랠그를 넘기는데 하나는 -i이고 다른 하나는 -t이다. -i플래그는 컨테이너에 STDIN을 연결하지 않았음에도 불구하고 컨테이너가 STDIN오픈을 해서 유지하도록 한다. -t플래그는 도커에서 생성한 컨테이너에 tty를 할당하도록 한다. 이것은 새로운 컨테이너에서 인터랙티브 쉘을 사용할 수 있도록 해준다. 이 라인은 컨테이너를 생성하기 위해 필요한 기본 설정이며 컨테이너를 데몬 서비스로 실행하기보다는 커맨드 라인에서 인터랙티브하게 사용하고 싶을 때 사용하는 명령어다.

다음으로 컨테이너를 생성하기 위해 어떤 이미지를 사용할지 도커에게 알려줘야 한다. 여기서 백그라운드에서는 어떤 일들이 일어나고 있을까? 먼저 도커가 우분투 이미지를 로컬에서 체크하낟. 로컬 도커 호스트에서 이미지를 찾지 못하면 Docker Inc에 의해 실행되는 Docker Hub 레지스트레에 연결하여 이곳에서 해당 이미지를 찾는다. 도커가 이미지를 찾게 되면 이미지를 다운로드하여 로컬 호스트에 저장한다. 

그리고 나서 도커는 이 이미지를 사용하여 파일 시스템에 새로운 컨테이너를 생성한다. 이 컨테이너는 네트워크, IP주소, 그리고 로컬 호스트와 통신할 브릿지 인터페이스를 가지고 있다. 마지막으로 도커에서 어떤 커맨드를 새로운 컨테이너에 실행할지 알려준다. 이 경우에는 /bin/bash 커맨드를 사용하여 Bash 쉘을 런칭한다. 

###첫 번째 컨테이너로 작업하기 

이제 새로운 컨테이너에 로그인을 해보자. xxxxxx라는 ID를 사용하며 루트 유저다. 이렇게 로그인을 하면 완전한 우분투 호스트가 되며 이 안에서 우분투 쉘에서 하는 것들을 대부분 할 수 있다. 

```
root@f7cbac22a02:/# hostname
f7cbac22a02
```

컨테이너의 호스트 이름이 컨테이너 ID라는 것을 할 수 있다. /etc/hosts 파일도 살펴보자 

```
root@f7cbac22a02:/# cat /etc/hosts
172.17.0.4 f7cbac22a02
```

도커는 IP주소를 갖는 컨테이너를 위해 호스트 엔트리도 추가했다. 네트워크 설정도 체크해보자 

```
root@f7cbac22a02:/# ip a
lo: <LOOPBACK...>
      127.0.0.1 ...
      ...
      
eth0: <BROADCAST...>
      172.17.0.4 ...
      ...
```

살펴본 대로 다른 호스트처럼 lo루프백 인터페이스와 IP주소가 172.17.0.4인 표준 eth 네트워크 인터페이스를 갖고 있다. 

실행되고 있는 프로세스도 체크할 수 있다. 

```
root@f7cbac22a02:/# ps -aux
```

작업을 끝내면 exit를 입력하고 우분투 호스트의 커맨드 프롬프트로 되돌아간다. 
그렇다면 컨테이너에서 무슨 일이 일어난 것일까? 현재 실행이 중지됐다. 컨테이너는 우리가 설정한 커맨드인 /bin/bash가 실행 중인 동안에만 실행할 수 있다. 컨테이너에서 빠져나오면 커맨드도 끝나고 컨테이너는 중지된다.

도커는 여전히 존재한다. docker ps -a커맨드를 사용하여 현재 컨테이너의 리스트를 볼 수 있다. 
기본적으로 docker ps를 실행하면 실행되고 있는 컨테이너를 확인할 수 있다. docker ps 커맨드를 사용할 때 -a 플래그를 함께 사용하면 중지됐거나 실행 중인 모든 컨테이너를 보여준다.  docker ps -l을 사용하면 실행 중이든 중지든 가장 최근에 실행했던 컨테이너를 보여준다. 

컨테이너에 대한 약간의 정보를 알 수 있다. 이 정보는 컨테이너 ID, 생성하기 위해 사용한 이미지, 마짐가으로 실행한 커맨드, 컨테이너가 생성된 시간 그리고 컨테이너가 종료됐을 때의 상태(0이면 정상 종료), 또한 각 컨테이너의 이름도 볼 수 있다. 

###컨테이너 네이밍

도커는 생성한 각 컨테이너 이름을 랜덤으로 생성한다. 자동으로 생성된 이름에 특정 컨테이너 이름을 설정하고 싶다면 --name 플래그를 사용하면 된다. 

```
$ sudo docker run --name jang -i -t ubuntu /bin/bash
```

올바른 컨테이너 이름은 다음의 문자들을 포함할 수 있다. a부터 z, A부터 Z 그리고 숫자 0부터 9, 언더스코아, 마침표 그리고 대시 무자들이다. 정규 표현식으로 표현할 수도 있다. 

이름은 오직 하나만 존재한다. 같은 이름을 갖는 두 개의 컨테이너를 생성하려고 하면 해당 커맨드는 실행에 실패한다. 새로운 컨테이너를 생성하기 위해서는 같은 이름을 갖는 이전의 컨테이너를 삭제해야 한다. 

###중지된 컨테이너 시작하기 

```
$ sudo docker start 컨테이너 이름 or id
```

###컨테이너 부착하기 

컨테이너는 docker run 커맨드를 사용하여 런칭했을 때 설정한 것과 같은 옵션으로 재시작된다. 따라서 실행 중인 컨테이너는 대기 중인 인터랙티브 세션이 있다. docker attach 커맨드를 사용하여 이 세션에 재부착할 수 있다

```
sudo docker attach jang
```

그리고 컨테이너의 배시 프롬프트로 다시 돌아오게 된다.
이 쉘을 종료한다면 컨테이너는 다시 중지된다. 

###데몬 컨테이너 생성하기 

데몬 컨테이너는 지금까지 사용해온 인터랙티브 세션을 갖고 있지 않으며 애플리케이션과 서빗를 실행할 때 유용하게 사용되는 방식이다. 대부분의 컨테이너는 아마도 데몬 형태가 될 것이다. 

```
$ docker run -name jang -d ubuntu /bin/sh -c "while true; do echo hello world; sleep 1; done"
```

여기서 -d 플래그를 사용하여 docker run 커맨드를 실행했고 이 커맨드를 사용하면 도커에게 컨테이너를 백그라운도로 동작시키라는 의미가 된다. 

###컨테이너에서 어떤 일들이 일어나는지 알아보기 

docker logs 커맨드는 컨테이너의 로그를 가지고 온다. 

```
$ docker logs jang
```

또한 -f 플래그를 사용한 tail -f 바이너리가 동작하는 것처럼 컨테이너 로그를 모니터링 할 수 있다. 

```
$ docker logs -f jang
```

> 로그 테일로부터 빠져나가기 위해서는 Ctrl + c를 사용한다. 

컨테이너 로그의 특정 부분을 테일링 할 수 있다. -f --lines 플래그를 사용하는 tail 커맨드와 비슷한 기능이다. 예를 들어 마지막에 있는 10 라인을 얻기 위해서는 docker logs --tail 10 jang 라고 사용하면 된다. 또한 docker logs --tail 0 -f jang와 같이 사용하면 전체 고르 파일을 읽어올 필요 없이 컨테이너의 로그를 가져올 수 있다. 

디버깅을 좀 더 쉽게 하기 위해서는 타임스탬프를 가진 로그 엔트리를 앞에 붙일 수 있다. 

```
$ docker logs -ft jang
```

###컨테이너 프로세스 조사 

컨테이너 로그에 추가로 컨테이너 내부에서 실행 중인 프로세스를 조사할 수 있다. 이 작을 하기 위해서 docker top 커맨드를 사용한다. 

```
$ docker top jang
```

각 프로세스를 볼 수 있고 실행 중인 사용자와 프로세스 ID를 알 수 있다. 

###데몬 컨테이너 중지  

데몬 컨테이너를 중지하려면 다음과 같이 docker stop 커맨드를 사용하면 된다. 

```
$ docker stop jang
```

> docker stop 커맨드는 SGTERM시그널을 도커 컨테이너의 실행 중인 프로세스에게 보낸다. 바쁘게 작업하고 있는 컨테이너를 중지시키려면 docker kill 커맨드를 사용하면 된다. 이 커맨드는 컨테이너의 프로세스에게 SIGKILL 시그널을 보낸다. 

지금 중지된 컨테이너의 상태를 체크하기 위해서는 docker ps -n jang 이 유용하다. 

###컨테이너에 대해 더 많은 정보 찾기 

docker inspect 커맨드를 사용하면 훨씬 더 많은 정보를 얻을 수 있다. 

```
$ docker inspect jang
```

docker inspect 커맨드는 컨테이너의 정보를 얻어오고 이름 명령어 네트워크 설정 그리고 다른 유용한 데이터 등을 포함한 설정 정보를 리턴한다. -f or --format 플래그를 사용하여 해시 결과를 얻어올 수 있도록 해주는 선택적 쿼리를 사용할 수도 있다. 

```
$ docker inspect --format='{{.Stage.Running }}' jang
```

위의 커맨드는 컨테이너의 실행 상태를 리턴한다. 또한 컨테이너의 IP 주소와 같은 유용한 정보도 얻을 수 있다.

```
$ docker inspect --format '{{ .NetworkSettings.IPAddress }}' \ 
```

> --format 혹은 -f 플래그는 얼핏 보이는 것보다 더 많은 기능을 갖고 있다. 실제로 전체 Go템플릿이 노출된다. 쿼리를 사용하여 Go 템플릿의 모든 기능을 사용할 수 있다. 

다중 컨테이너 조사하기 

```
$ docker inspect --format '{{.Name}} {{.State.Running}}' \ 
```

쿼리를 사용해서 조사한 결과 해시에서 일부분만을 선택해서 리턴할 수 있다. 

> 컨테이너를 조사할 때 추가로 /var/lib/docker 디렉터리를 탐색해서 도커의 동장 방법에 대해 더 많은 정보를 얻을 수 있다. 이 디렉터리를 여러분이 사용한 이미지 컨테이너 컨테이너 설정 등이 저장되어 있다. 모든 컨테이너는 /var/lib/docker/container 디렉터리에서 찾을 수 있다. 

###컨테이너 삭제 

docker rm 커맨드를 사용하여 컨테이너를 삭제할 수 있다. 

```
$ docker rm jang
```

현재 모든 컨테이너를 삭제할 수 있는 방법은 없다. 그러나 다음과 같은 커맨드를 사용하여 비슷하게 할 수 있다. 

```
$ docker rm docker ps -a -q 
```

docker ps 커맨드를 사용하여 현재 존재하는 모든 컨테이너를 리스트한다. -a 플래그는 모든 컨테이너를 리스트하고 -q 플래그는 컨테이너에 대한 다른 정보는 놔두고 ID만을 리턴한다. 

> 실행 중인 도커 컨테이너를 삭제할 수 없다는 것이 중요하다. 먼저 docker stop 커맨드나 docker kill 커맨드를 사용하여 실행 중인 컨테이너를 중지시켜야 한다. 
