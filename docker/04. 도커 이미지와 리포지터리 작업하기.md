도커 이미지와 리포지터리 작업하기
=================================

###도커 이미지란?

도커 이미지는 각각의 레이어로 구성된 파일 시스템으로 되어 있다. 베이스는 부트 파일 시스템인 bootfs이며 이러한 구조는 우리가 흔히 사용하는 일반적인 리눅스/유닉스 부트 파일 시스템과 비슷하다. 도커 사용자는 부트 파일 시스템을 액세스 할 일이 거의 없다. 실제로 컨테이너가 부팅되면 컨테이너는 메모리로 이동하고 부트 파일 시스템의 마운트는 해제되며 따라서 initrd 디스크 이미지가 확보하여 사용하고 있는 RAM 역시 해제된다.

지금까지는 일반적인 리눅스 가상화 스택과 거의 비슷하다. 도커에서 살펴봐야 할 그 다음 레이어는 루트 파일시스템이며 rootfs이다. 이 rootfs는 부트 파일 시스템 위에 존재한다. 이 rootfs는 운영체제 중 하나가 될 수 있다. 예를 들어 데비안이나 우분투 파일 시스템이 이에 해당한다. 

일반적인 리눅스 부트에서는 루트 파일 시스템은 읽기-전용으로 마운트되고 부팅된 후에 읽기-쓰기로 바뀐다. 그리고 통합 체크(integrity check)가 실행된다. 그러나 도커에서의 루트 파일 시스템은 읽기-전용 모드로 계속 유지되며 이 루트 파일 시스템에 읽기-전용 파일 시스템을 추가하여 유니언 마운트가 갖는 장점을 갖게된다. 유니언 마운트는 한 번에 여러 파일 시스템을 마운트하지만 마치 하나의 파일 시스템처럼 보이도록 하는 마운트를 의미한다. 유니언 마운트는 상위에 각각의 파일 시스템을 오버레이하여 결과적으로 사용자가 인식하기에는 하나의 내부 파일 시스템을 사용하도록 해주며 이 파일 시스템에는 각각의 파일 시스템의 일부 혹은 전체 파일들과 서브디렉터리 모두 포함할 수도 있다. 

도커는 이러한 파일 시스템 이미지 각각을 호출한다. 이미지는 다른 이미지의 위에 레이어된다. 아래에 존재하는 이미지를 부모 이미지라고 하며 베이스 이미지라고 하는 마지막 이미지가 위치하고 있는 이미지 스택의 끝에 도달할 때까지 각 레이어를 탐색할 수 있다. 도커는 읽기-쓰기 파일 시스템을 맨 상위에 마운트한다. 이 파일 시스템에서 도커 컨테이너를 실행하도록 하는 프로세스가 존재한다. 

도커가 맨 처음 컨테이너를 시작할 때 초기 읽기-쓰기 레이어는 비어 있다. 변경 사항이 발생되면 그 변경 사항은 이 읽기-쓰기 레이어에 적용된다. 예를 들어 파일을 변경하려면 그 파일은 아래에 존재하는 읽기-전용 레이어로부터 읽기-쓰기 레이어로 복사된다. 파일의 읽기-전용 버전은 사라지는 것이 아니라 계속 존재하지만 이 순간에는 복사본 아래에 숨겨져 있다. 

이러한 패턴을 일반적으로 cow라고 하며 도커를 강력하게 만들어 준 기능 중 하나다. 각 읽기-전용 이미지 레이어는 읽기-전용이다. 이 이미지는 절대 변경할 수 없다. 컨테이너가 생성될 때 도커는 이미지의 스택으로부터 빌드되며 맨 위에읽기-쓰기 레이어를 추가한다. 이 레이어는 아래의 있는 이미지 레이어의 정보를 가져온다. 이 정보는 여러 설정 데이터 컨테이너의 상태 등이다. 이전 장에서 설명했듯이 컨테이너는 변경될 수 있으며 상태를 갖고 있으며 컨테이너는 시작하거나 실행 중에 중지될 수 있다. 이미지-레이어 프레임워크는 이미지를 빠르게 빌드할 수 있도록 해주며 애플리케이션과 서비스를 가진 컨테이너를 빠르게 실행할 수 있도록 해준다. 

###도커 이미지의 리스트 

```
$sudo docker images
```

이러한 로컬 이미지는 로컬 도커 호스트의 /var/lib/docker 디렉터리에 존재한다. 각 이미지는스토리지 드라이버를 위한 디렉터리 이름 안에 존재한다.

이미지는 리포지터리에 존재하며 리포지터리는 레지스트리에 존재한다. 디폴트 레지스트리는 Docker. Inc에서 관리하는 퍼블릭 레지스트리인 도커 허브다. 이미지 리포지터리는 깃 리포티저리와 매우 비슷하다. 이미지와 이미지에 대한 메타데이터를 포함하고 있다. 각 리포지터리는 여러 개의 이미지를 갖고 있다. ubuntu:14.04에서 리포지터리 이름은 우분투이고 14.04는 이미지의 태그로 사용된다. 리포지터리에는 두 가지 타입이 있다. 하나는 사용자 리포티저리이며 도커 사용자가 만든 이미지들을 포함한다. 다른 하나는 최상위 레벨 리포지터리이며 도커를 개발하는 개발자들이 관리하는 리포지터리이다. 사용자 리포지터리는 사용자 이름과 리포지터리 이름으로 되어있다. 예를 들면 jamtur01/puppet과 같은 형태이다. 한편 최상위 레벨 리포지터리는 우분투와 같은 리포지터리 이름으로만 되어 있다. 최상위 레벨의 레포지터리는 Docker inc에서 관리하며 벤더들이 여러분이 빌드하려는 베이스 이미지를 제공하도록 최상위 레벨을 관리한다. 최상위 레벨 리포지터리에 있는 이미지들은 벤더와 Docker Inc로부터 공식적인 승인을 받아야 한다. 여기에 포함되어 있는 이미지는 상당히 잘 만들어져있고 보안성이 뛰어나며 최신버전이다. 

이미지 리스트에 대해 다른 것들은 무엇이 있을까 ? 이미지는 여러 개의 우분투 이미지에 대한 엔트리를 포함하고 있다. 여기서는 우분투에 대한 하나의 이미지만을 로드했다. 그렇다면 왜 13개의 다른 엔트리에 대한 리스트가 존재하는 것일까? 사실 우분투 이미지는 하나만 존재하는 것은 아니다. 실제로 하나의 리포지터리 안에 모여 있는 이미지는 여러 가지다. 이 경우에 우분투 이미지를 다운로드하면 실제로는 여러 가지 버전 즉 10.04, 12.04, 13.04 그리고 14.04를 포함한 여러 버전으로 되어 있는 우분투 운영체제들을 얻게 된다. 

> 우리가 우분투 운영체제라고 부르지만 실제로는 이 이미지는 완전한 운영체제는 아니다. 배포판을 실행하기 위해 최소한의 런타임으로만 구성되어 있는 버전이다. 

도커에서는 태그를 사용하여 리포지터리 안에 있는 이미지들을 식별한다. 원하는 이미지를 얻기 위해서는 정확하게 ubuntu:12.04라고 기술하는 것이 좋다. 


###이미지 가져오기

dokcer run 커맨드를 사용하면 컨테이너를 실행할 때 이미지를 다운로드 한다. 한편 docker pull 커맨드를 사용하면 이미지를 바로 가져올 수 있다. docker pull을 사용하는 것은 새로운 이미지로부터 컨테이너를 런칭하는 시간을 줄여준다.

```
$docker pull fedora
```

페도라 이미지만 보이도록 해보자 

```
$docker images fedora
```

###이미지 검색 

docker search 커맨드를 사용하면 공식적으로 사용할 수 있는 이미지를 모두 검색할 수 있다. 

```
$docker search puppet
```

이미지를 검색하면 다음과 같은 정보를 리턴할 것이다. 

- 리포지터리 이름
- 이미지 설명
- 별(인기도)
- 공식(업스트림 개발자에 의해 관리되는 이미지)
- 자동(도커 허브의 자동 빌드 프로세스에 의해 빌드된 이미지)


###자신의 이미지 빌드하기

도커 이미지를 생성하는 방법은 두 가지 방법이 있다.

- docker commit 커맨드를 통해
- Dockerfile을 사용

docker commit 방법은 추천하는 방법은 아니다.  

```
$ touch Dockerfile
```

SSH서버로서 동작하는 예제를 살펴보자 

```
#version: 0.0.1
FROM ubuntu:12.04
MAINTAINER lee "leeplay@example.com"
RUN apt-get update
RUN apt-get intall -y openssh-server
RUN mkdir /var/run/sshd
RUN echo "root:password" | chpasswd
EXPOSE 22
```

Dockerfile에는 인수와 함께 여러 명령어들을 포함한다. 예를 들어 FROM의 경우는 대문자가 되어야 하고 그 다음에 인수가 있어야 한다. Dockerfile에 있는 명령어들은 톱다운 으로 처리되된다. 각 명령어는 이미지에 새로운 레이어를 추가하고 이미지를 커밋한다. 명령어를 실행하는 도커는 다음의 워크 플로우를 따른다. 

- 도커는 이미지로부터 컨테이너를 실행한다.
- 명령어는 컨테이너에서 실행되고 변경 사항을 생성한다.
- 도커는 새로운 레이어를 커밋하기 위해 docker commit와 같은 기능을 실행한다.
- 그리고 나서 도커는 이 새로운 이미지로부터 새로운 컨테이너를 실행한다.
- 파일에 있는 다음 명령어가 실행되고 그 과정은 모든 명령어가 실행될 때까지 반복된다.

Dockerfile 어떤 이유에서든지 중지된다면 중지된 상태를 나중에 사용할 수 있도록 이미지로 남겨 둔다. 이 이미지는 디버깅할 때 매우 유용하다. 이 이미지로부터 컨테이너를 인터랙티브하게 실행할 수 있고 생성된 마지막 이미지를 사용하여 명렁아기 실패한 원인을 디버깅 할 수 있다.

Dockerfile에 있는 첫 번째 명령어는 항상 FROM이 되어야 한다. FROM 명령어는 기존 이미지를 설정하여 그 다음에 나오는 명령어들이 동작할 수 있도록 한다. 이 이미지를 베이스 이미지라고 한다. 

다음으로 MAINTAINER 명령어를 설정한다. 이것은 이미지의 저작자가 누구인지 그 리고 이메일 주소가 무엇인지를 도커에게 알려준다. 

RUN 명령어는 현재 이미지의 명령어를 실행한다.이 명령어는 각각의 새로운 레이어를 생성하고 성공한다면 그 레이어를 커밋하고 다음 명령어를 실행한다. 

기본적으로 RUN 명령어는 명령어 래퍼인 \bin\sh -c를 사용하여 쉘 안에서 실행된다. 쉘이 없는 플랫폼에서 명령어를 실행하거나 쉘 없이 실행하고 싶다면(예를 들어 쉘 문자열인 프롬프트가 화면에 출력되는 것을 원치 않는 경우) exec 포맷에서 명령어를 사용하도록 설정할 수 있다. 

```
RUN ["apt-get", "install", "y", "openssh-server"]
```

이 포맷을 사용하여 실행할 명령어를 포함한 배열을 설정한다. 그리고 나서 각 파라미터를 명령어에 전달한다. 

EXPOSE 이 명령어는 컨테이너에 있는 애플리케이션이 컨테이너에 있는 특정 포트를 사용하도록 한다. 이것은 컨테이너에 있는 해당 포트에 실행하는 어떤 서비스라도 자동으로 액세스 할 수 있도록 한다는 의미는 아니다.보안상의 이유로 인해 도커는 포트를 자동으로 오픈할 수 없으며 docker run 커맨드를 사용하는 컨테이너를 실행할 때 오픈하도록 대기한다. 이 이미지로부터 새로운 컨테이너를 생성할 때 짧게 이에 대해 살펴보게 될 것이다. 여러 EXPOSE 명령어를 설정해서 여러 포트가 노출되도록 표시한다.

> 도커는 EXPOSE 명령어를 사용하여 컨테이너들을 함께 링크하는 데 도움을 준다. 
