도커 이미지와 리포지터리 작업하기
=================================

###도커 이미지란?

도커 이미지는 각각의 레이어로 구성된 파일 시스템으로 되어 있다. 베이스는 부트 파일 시스템인 bootfs이며 이러한 구조는 우리가 흔히 사용하는 일반적인 리눅스/유닉스 부트 파일 시스템과 비슷하다. 도커 사용자는 부트 파일 시스템을 액세스 할 일이 거의 없다. 실제로 컨테이너가 부팅되면 컨테이너는 메모리로 이동하고 부트 파일 시스템의 마운트는 해제되며 따라서 initrd 디스크 이미지가 확보하여 사용하고 있는 RAM 역시 해제된다.

지금까지는 일반적인 리눅스 가상화 스택과 거의 비슷하다. 도커에서 살펴봐야 할 그 다음 레이어는 루트 파일시스템이며 rootfs이다. 이 rootfs는 부트 파일 시스템 위에 존재한다. 이 rootfs는 운영체제 중 하나가 될 수 있다. 예를 들어 데비안이나 우분투 파일 시스템이 이에 해당한다. 

일반적인 리눅스 부트에서는 루트 파일 시스템은 읽기-전용으로 마운트되고 부팅된 후에 읽기-쓰기로 바뀐다. 그리고 통합 체크(integrity check)가 실행된다. 그러나 도커에서의 루트 파일 시스템은 읽기-전용 모드로 계속 유지되며 이 루트 파일 시스템에 읽기-전용 파일 시스템을 추가하여 유니언 마운트가 갖는 장점을 갖게된다. 유니언 마운트는 한 번에 여러 파일 시스템을 마운트하지만 마치 하나의 파일 시스템처럼 보이도록 하는 마운트를 의미한다. 유니언 마운트는 상위에 각각의 파일 시스템을 오버레이하여 결과적으로 사용자가 인식하기에는 하나의 내부 파일 시스템을 사용하도록 해주며 이 파일 시스템에는 각각의 파일 시스템의 일부 혹은 전체 파일들과 서브디렉터리 모두 포함할 수도 있다. 

도커는 이러한 파일 시스템 이미지 각각을 호출한다. 이미지는 다른 이미지의 위에 레이어된다. 아래에 존재하는 이미지를 부모 이미지라고 하며 베이스 이미지라고 하는 마지막 이미지가 위치하고 있는 이미지 스택의 끝에 도달할 때까지 각 레이어를 탐색할 수 있다. 도커는 읽기-쓰기 파일 시스템을 맨 상위에 마운트한다. 이 파일 시스템에서 도커 컨테이너를 실행하도록 하는 프로세스가 존재한다. 

도커가 맨 처음 컨테이너를 시작할 때 초기 읽기-쓰기 레이어는 비어 있다. 변경 사항이 발생되면 그 변경 사항은 이 읽기-쓰기 레이어에 적용된다. 예를 들어 파일을 변경하려면 그 파일은 아래에 존재하는 읽기-전용 레이어로부터 읽기-쓰기 레이어로 복사된다. 파일의 읽기-전용 버전은 사라지는 것이 아니라 계속 존재하지만 이 순간에는 복사본 아래에 숨겨져 있다. 

이러한 패턴을 일반적으로 cow라고 하며 도커를 강력하게 만들어 준 기능 중 하나다. 각 읽기-전용 이미지 레이어는 읽기-전용이다. 이 이미지는 절대 변경할 수 없다. 컨테이너가 생성될 때 도커는 이미지의 스택으로부터 빌드되며 맨 위에읽기-쓰기 레이어를 추가한다. 이 레이어는 아래의 있는 이미지 레이어의 정보를 가져온다. 이 정보는 여러 설정 데이터 컨테이너의 상태 등이다. 이전 장에서 설명했듯이 컨테이너는 변경될 수 있으며 상태를 갖고 있으며 컨테이너는 시작하거나 실행 중에 중지될 수 있다. 이미지-레이어 프레임워크는 이미지를 빠르게 빌드할 수 있도록 해주며 애플리케이션과 서비스를 가진 컨테이너를 빠르게 실행할 수 있도록 해준다. 

###도커 이미지의 리스트 

```
$sudo docker images
```

이러한 로컬 이미지는 로컬 도커 호스트의 /var/lib/docker 디렉터리에 존재한다. 각 이미지는스토리지 드라이버를 위한 디렉터리 이름 안에 존재한다.

이미지는 리포지터리에 존재하며 리포지터리는 레지스트리에 존재한다. 디폴트 레지스트리는 Docker. Inc에서 관리하는 퍼블릭 레지스트리인 도커 허브다. 이미지 리포지터리는 깃 리포티저리와 매우 비슷하다. 이미지와 이미지에 대한 메타데이터를 포함하고 있다. 각 리포지터리는 여러 개의 이미지를 갖고 있다. ubuntu:14.04에서 리포지터리 이름은 우분투이고 14.04는 이미지의 태그로 사용된다. 리포지터리에는 두 가지 타입이 있다. 하나는 사용자 리포티저리이며 도커 사용자가 만든 이미지들을 포함한다. 다른 하나는 최상위 레벨 리포지터리이며 도커를 개발하는 개발자들이 관리하는 리포지터리이다. 사용자 리포지터리는 사용자 이름과 리포지터리 이름으로 되어있다. 예를 들면 jamtur01/puppet과 같은 형태이다. 한편 최상위 레벨 리포지터리는 우분투와 같은 리포지터리 이름으로만 되어 있다. 최상위 레벨의 레포지터리는 Docker inc에서 관리하며 벤더들이 여러분이 빌드하려는 베이스 이미지를 제공하도록 최상위 레벨을 관리한다. 최상위 레벨 리포지터리에 있는 이미지들은 벤더와 Docker Inc로부터 공식적인 승인을 받아야 한다. 여기에 포함되어 있는 이미지는 상당히 잘 만들어져있고 보안성이 뛰어나며 최신버전이다. 

이미지 리스트에 대해 다른 것들은 무엇이 있을까 ? 이미지는 여러 개의 우분투 이미지에 대한 엔트리를 포함하고 있다. 여기서는 우분투에 대한 하나의 이미지만을 로드했다. 그렇다면 왜 13개의 다른 엔트리에 대한 리스트가 존재하는 것일까? 사실 우분투 이미지는 하나만 존재하는 것은 아니다. 실제로 하나의 리포지터리 안에 모여 있는 이미지는 여러 가지다. 이 경우에 우분투 이미지를 다운로드하면 실제로는 여러 가지 버전 즉 10.04, 12.04, 13.04 그리고 14.04를 포함한 여러 버전으로 되어 있는 우분투 운영체제들을 얻게 된다. 

> 우리가 우분투 운영체제라고 부르지만 실제로는 이 이미지는 완전한 운영체제는 아니다. 배포판을 실행하기 위해 최소한의 런타임으로만 구성되어 있는 버전이다. 

도커에서는 태그를 사용하여 리포지터리 안에 있는 이미지들을 식별한다. 원하는 이미지를 얻기 위해서는 정확하게 ubuntu:12.04라고 기술하는 것이 좋다. 


###이미지 가져오기

dokcer run 커맨드를 사용하면 컨테이너를 실행할 때 이미지를 다운로드 한다. 한편 docker pull 커맨드를 사용하면 이미지를 바로 가져올 수 있다. docker pull을 사용하는 것은 새로운 이미지로부터 컨테이너를 런칭하는 시간을 줄여준다.

```
$docker pull fedora
```

페도라 이미지만 보이도록 해보자 

```
$docker images fedora
```

###이미지 검색 

docker search 커맨드를 사용하면 공식적으로 사용할 수 있는 이미지를 모두 검색할 수 있다. 

```
$docker search puppet
```

이미지를 검색하면 다음과 같은 정보를 리턴할 것이다. 

- 리포지터리 이름
- 이미지 설명
- 별(인기도)
- 공식(업스트림 개발자에 의해 관리되는 이미지)
- 자동(도커 허브의 자동 빌드 프로세스에 의해 빌드된 이미지)


###자신의 이미지 빌드하기

도커 이미지를 생성하는 방법은 두 가지 방법이 있다.

- docker commit 커맨드를 통해
- Dockerfile을 사용

docker commit 방법은 추천하는 방법은 아니다.  

```
$ touch Dockerfile
```

SSH서버로서 동작하는 예제를 살펴보자 

```
#version: 0.0.1
FROM ubuntu:12.04
MAINTAINER lee "leeplay@example.com"
RUN apt-get update
RUN apt-get intall -y openssh-server
RUN mkdir /var/run/sshd
RUN echo "root:password" | chpasswd
EXPOSE 22
```

Dockerfile에는 인수와 함께 여러 명령어들을 포함한다. 예를 들어 FROM의 경우는 대문자가 되어야 하고 그 다음에 인수가 있어야 한다. Dockerfile에 있는 명령어들은 톱다운 으로 처리되된다. 각 명령어는 이미지에 새로운 레이어를 추가하고 이미지를 커밋한다. 명령어를 실행하는 도커는 다음의 워크 플로우를 따른다. 

- 도커는 이미지로부터 컨테이너를 실행한다.
- 명령어는 컨테이너에서 실행되고 변경 사항을 생성한다.
- 도커는 새로운 레이어를 커밋하기 위해 docker commit와 같은 기능을 실행한다.
- 그리고 나서 도커는 이 새로운 이미지로부터 새로운 컨테이너를 실행한다.
- 파일에 있는 다음 명령어가 실행되고 그 과정은 모든 명령어가 실행될 때까지 반복된다.

Dockerfile 어떤 이유에서든지 중지된다면 중지된 상태를 나중에 사용할 수 있도록 이미지로 남겨 둔다. 이 이미지는 디버깅할 때 매우 유용하다. 이 이미지로부터 컨테이너를 인터랙티브하게 실행할 수 있고 생성된 마지막 이미지를 사용하여 명렁아기 실패한 원인을 디버깅 할 수 있다.

Dockerfile에 있는 첫 번째 명령어는 항상 FROM이 되어야 한다. FROM 명령어는 기존 이미지를 설정하여 그 다음에 나오는 명령어들이 동작할 수 있도록 한다. 이 이미지를 베이스 이미지라고 한다. 

다음으로 MAINTAINER 명령어를 설정한다. 이것은 이미지의 저작자가 누구인지 그 리고 이메일 주소가 무엇인지를 도커에게 알려준다. 

RUN 명령어는 현재 이미지의 명령어를 실행한다.이 명령어는 각각의 새로운 레이어를 생성하고 성공한다면 그 레이어를 커밋하고 다음 명령어를 실행한다. 

기본적으로 RUN 명령어는 명령어 래퍼인 \bin\sh -c를 사용하여 쉘 안에서 실행된다. 쉘이 없는 플랫폼에서 명령어를 실행하거나 쉘 없이 실행하고 싶다면(예를 들어 쉘 문자열인 프롬프트가 화면에 출력되는 것을 원치 않는 경우) exec 포맷에서 명령어를 사용하도록 설정할 수 있다. 

```
RUN ["apt-get", "install", "y", "openssh-server"]
```

이 포맷을 사용하여 실행할 명령어를 포함한 배열을 설정한다. 그리고 나서 각 파라미터를 명령어에 전달한다. 

EXPOSE 이 명령어는 컨테이너에 있는 애플리케이션이 컨테이너에 있는 특정 포트를 사용하도록 한다. 이것은 컨테이너에 있는 해당 포트에 실행하는 어떤 서비스라도 자동으로 액세스 할 수 있도록 한다는 의미는 아니다.보안상의 이유로 인해 도커는 포트를 자동으로 오픈할 수 없으며 docker run 커맨드를 사용하는 컨테이너를 실행할 때 오픈하도록 대기한다. 이 이미지로부터 새로운 컨테이너를 생성할 때 짧게 이에 대해 살펴보게 될 것이다. 여러 EXPOSE 명령어를 설정해서 여러 포트가 노출되도록 표시한다.

> 도커는 EXPOSE 명령어를 사용하여 컨테이너들을 함께 링크하는 데 도움을 준다. 

###Dockerfile로부터 이미지 빌드하기


```
$ docker build -t="leehk1227/sshd:v1" .
```

> 어떤 태그도 설정하지 않으면 도커는 자동으로 이미지에 latesd라는 태그를 붙인다. 

다음과 같이 git 리포티저티리를 Dockerfile의 소스로 설정할 수도 있다.

```
$ sudo docker build -t="leehk1227/sshd:v1" \ 
git@github.com:leehk1227/docker-sshd
```

도커는 깃 리포지터리의 루트에 Dockerfile이 있다고 가정한다. 그러나 도커 빌드 과정으로 되돌아가보자. 블드 컨텍스트는 도커 데몬으로부터 업로드됐다는 것을 알 수 있다. 

###Dockerfile과 빌드 캐시

각 과정의 결과를 이미지로 커밋한 것처럼 도커는 이미지를 빌드하는 데 상당히 막강한 기능을 갖고 있다. 이전 레이어를 캐시로 처리하게 된다. 스텝 1부터 3까지 변경된 사항이 필요 없다면 이전에 빌드된 이미지를 캐시와 스타팅 포인트로 사용하게 된다. 이렇게 하게 되면 이전 스텝이 변경되지 않는 경우 이미지를 빌드할 때의 많은 시간을 절약할 수 있다. 때때로 캐시를 사용하고 싶지 않을 수 있다. 예를 들어 앞의 스텝 3인 apt-get update를 캐싱했다면 APT 패키지 캐시를 리프레시 하지 않게 ㅗ딘다. 새로운 버전의 패키지를 얻기 위해 이 작업을 하고 싶을 수도 있다. 캐시를 사용하지 않으려면 아래처럼 하면 된다.

```
$ docker build --no-cache -t="leehk1227/sshd"
```

###템플릿을 위한 빌드 캐시 사용하기

빌드 캐시의 결과처럼 Dockerfiles를 간단한 템플릿의 형태(예를 들어 패키지 리포지터리를 추가하거나 캐시가 히트됐다는 것을 보장하기 위해 파일의 맨 위에 있는 패키지를 업데이트하는 것등)로 빌드할 수 있다.일반적으로 Dockerfile의 맨 위에 명령어들의 같은 템플릿을 셋을 갖고 있다. 

새로운 Dockerfile을 사용해보자 ubuntu:14.04의 베이스 이미지를 선택하기 위해 FROM명령어를 사용했다. 다음으로 MAINTAINER명령어를 사용하면 본인의 컨택 정보를 자세하게 제공할 수 있다. 이때 ENV명령어는 이미지에서 환경 변수를 설정한다. 이 경우에 ENV 명령어를 사용하여 REFRESHED_AT라고 하는 환경 변수를 설정한다. 이 명령어는 템플릿이 마지막으로 업데이트 된 것을 보여준다. 마지막으로 apt-get-qq update명령어를 RUN 명령어에서 설정한다. 이 명령어는 실행될 때 APT 패키지 캐시를 리프레시하고 최신 패키지가 설치될 준비가 됐다는 것을 보장한다. 

템플릿을 사용하여 빌드를 리프레시 하고 싶을 때 ENV 명령어에 있는 날짜를 변경한다. 그러고 나면 도커는 ENV 명령어를 히트했을 때 캐시를 리셋하고 캐시에 의존하지 않고 명령어들을 실행한다. 이것은 패키지 캐시가 최신 내용으로 리프레시 됐다는 것을 의미한다. 

###새로운 이미지 보기

```
$ docker images leehk1227/sshd
```

자세히 알고 싶다면 

```
$ docker history leehk1227/ssd
```

###새로운 이미지에서 컨테이너 런칭하기

```
$ docker run -d -p 22 --name sshd leehk1227/sshd \
/usr/sbin/sshd -D
```
-d 옵션은 도커가 백그라운드로 동작하도록 한다. SSH데몬과 같은 오래 실행되는 프로세스를 실행하도록 해준다. 
-p 옵션은 도커가 실행 중에 어떤 네트워크 포트를 오픈할지를 관리한다. 컨테이너를 실행할 때 도커는 도커의 호스트에 포트를 할당하는 두 개의 방법을 갖고 있다.

- 도커는 컨테이너에서 포트 22로 매핑되어 있는 도커 호스트에 랜덤으로 49000부터 49900까지 높은 포트를 할당한다.
- 컨테이너에서 포트 22로 매핑되어 있는 도커 호스트에 특정 포트를 할당할 수 있다.

이는 도커 컨테이너의 포트 22에 연결될 도커 호스트에 랜덤 포트를 오픈한다. 어떤 포트가 할당됐는지 docker ps 커맨드를 사용해서 살펴보자 

```
$ docker ps -l
```

```
$ docker port id 22
```

22로 매핑한 것과 마찬가지로 컨테이너 ID와 컨테이너 포트를 설정할 수 있으며 매핑된 포트 49154가 리턴된다.

-p 옵션은 또한 포트가 어떻게 호스트에 오픈됐는지에 대해서도 설정할 수 있다. 예를 들어 도커가 포트를 특정 포트에 바인딩할 수 있도록 설정할 수 있다.

```
$ docker run -d -p 22:22 --name sshd leehk1227/sshd \
/usr/sbin/sshd -D
```

로컬 호스트에서 컨테이너의 포트 22를 포트 22에 바인딩한다. 이렇게 직접 바인딩하는 것은 상당히 조심해야 한다. 여러 컨테이너를 실행하고 있다면 단지 하나의 컨테이너가 로컬 호스트의 특정 포트를 바인딩하게 된다. 이는 도커의 유연성을 제한한다. 

```
$ docker run -d -p 2222:22 --name sshd leehk1227/sshd \
/usr/sbin/sshd -D
```

이렇게 컨테이너의 포트 22를 로컬 호스트의 포트 2222에 바인딩한다.


```
$ docker run -d -p 127.0.0.1:22:22 --name sshd leehk1227/sshd \
/usr/sbin/sshd -D
```

여기에서 컨테이너의 포트를 22를 호스트의 127.0.0.1 인터페이스에 바인딩했다. 또한 같은 구조를 사용하여 랜덤 포트를 바인딩할 수도 있다.


```
$ docker run -d -p ::22 --name sshd leehk1227/sshd \
/usr/sbin/sshd -D
```

도커는 또한 쇼컷을 갖고 있으며 -P는 Dockerfile에서 EXPOSE 명령어를 통해 설정한 모든 포트를 오픈하도록 해준다.


```
$ docker run -d -P --name sshd leehk1227/sshd \
/usr/sbin/sshd -D
```

로컬 호스트의 랜덤 포트에 포트 22를 오픈한다. 또한 이미지를 빌드하는 Dockerfile에서 다른 EXPOSE명령어를 사용하여 설정한 추가 포트를 오픈할 수도 있다. 

이 포트 넘버를 사용해서 호스트의 IP주소나 127.0.0.1의 로컬 호스트를 사용한 컨테이너가 실행 중인 것을 SSH로 확인할 수 있다. 

> ipconfig나 ip addr 커맨드를사용하여 로컬 호스트의 ip 주소를 찾을 수 있다.

ssh를 통한 컨테이너의 연결 

```
$ssh -p 49154 root@localhost
```

이제 도커 기반의 SSH 서버를 사용할 수 있게 됐다. 

###Dockerfile명령어

CMD 명령어는 컨테이너가 런칭됐을 때 실행하도록 하는 명령어를 설정하는 역하을 한다. RUN 명령어와 비슷하지만 컨테이너가 빌드될 때 명령어를 실행하기보다는 docker run 커맨드를 사용하여 컨테이너를 런칭할 때 실행하게 하도록 명령어를 설정하는 것과 비슷하다. 

```
$ docker run -i -t ubuntu /bin/bash
```

```
CMD ["bin/bash"]
```

다음과 같이 파라미터를 설정할 수도 있다. 

```
CMD ["bin/bash", "-l"]
```

/bin/bash 명령어에 -l 플래그를 넘긴다. 

마지막으로 docker run  커맨드를 사용하여 CMD 명령어를 오버라이드할 수 있다는 것을 이해하는 것이 중요하다.
Dockerfile에서 CMD를 설정하고 docker run 커맨드 라인을 설정하면 커맨드 라인은 Dockerfile의 CMD명령어를 오버라이드 하게 된다. 

이러한 과정을 좀 더 살펴보자 Dockerfile은 CMD를 포함하고 있다. 

```
CMD ["/bin/bash"]
```

```
$ docker run -t -i leehk1227/test
```

docker run의 끝에서 실행되도록 커맨드를 설정하지 않았다. 대신에 도커는 CMD명령어에 의해 설정된 커맨드를 사용했다. 

```
$ docker run -t -t leehk1227/test /bin/ps
```

여기서는 실행 중인 프로세스를 리스트하기 위해 /bin/ps 커맨드를 설정했다 쉘을 런칭하는 대신 컨테이너는 실행 중인 프로세스나 중지된 프로세스를 간단하게 리턴하고 CMD 명령어에서 설정딘 커맨드를 오버라이드 한다. 

> Dockerfile에서는 하나의 CMD 명령어만을 설정할 수 있다. 마지막 명령어를 사용한다. 

ENTRYPOINT 

CMD 명령어와는 무엇이 다르며 왜 필요할까? ENTRYPOINT 명령어는 쉽게 오버라이드 되지 않는 커맨드를 제공한다. 대신에 docker run 커맨드 라인에 설정하는 인수는 ENTRYPOINT에서 설정한 커맨드에게 넘겨준다. 

```
ENTRYPOINT ["/usr/sbin/sshd"]
```

CMD 명령어와 같이 배열에 추가하여 파라미터를 설정한다. 

```
ENTRYPOINT ["/usr/sbin/sshd", "-d"]
```

> 앞에서 본 CMD 명령어와 마찬가지로 /bin/sh -c 처럼 동작하는 커맨드에 대한 문제를 피하기 위해서 배열에 ENTRYPOINT 명령어를 설정할 수 있다. 

이제 이미지를 재빌드하고 leehk1227/sshd 이미지에서 새로운 커네이너를 런칭하자 

```
$ docker build -t="leehk1227/sshd"
```

```
$ docker run -d leehk1227/sshd -D
```

앞에서 본 것처럼 이미지를 재빌드하고 연결된 컨테이너를 런칭했다. 인수 -D를 설정했다. 이 인수는 ENTRYPOINT 명령어에 설정된 커맨드로 넘겨지며 결국 /usr/sbin/sshd -D가 된다 이 커맨드는 그러고 나서 SSH데몬으로 포어그라운드로 런칭하고 SSH서버로서 컨테이너가 실행되도록한다. 

ENTRYPOINT와 CMD를 조합하여 사용할 수도 있다. 예를 들어 

```
ENTRYPOINT ["/usr/sbin/sshd"]
CMD ["-T"]
```

이제 컨테이너를 런칭할 때 설정한 옵션으로 SSH 데몬으로 넘기면 된다. 예를 들어 포어그라운드에서 데몬을 실행하기 위해 위에서 한 것처럼 -D 를 설정한다. 컨테이너 넘길 것을 아무것도 설정하지 않으면 -T가 CMD 명령어에 의해 넘겨지며 SSH데몬 설정 /usr/sbin/sshd -T를 리턴한다. 

> 런타임에 필요하면 ENTRYPOINT를 docker run 커맨드와 -entrypoint 플래그를 사용하여 오버라이드 할 수 있다. 

WORKDIR

WORKDIR은 ENTRYPOINT나 CMD가 컨테이너가 이미지로부터 런칭될 때 실행되는 작업 디렉터리를 설정하는 방법을 제공한다.
이 명령어를 사용하여 여러 개의 명령어나 혹은 최종 컨테이너를 위한 작업 디레거리로 설정하는 데 사용한다.

```
WORKDIR /opt/webapps/db
RUN ...
```

런타임 때 -w 플래그를 사용하여 작업 디렉터리를 오버라이드 한다. 예를 들면 다음과 같다

```
$ docker run -it -w /var/log ubuntu pwd
```

ENV

이미지를 빌드하는 과정 중 환경 변수를 설ㅈ어하는 데 사용한다 

```
ENV RVM_PATH /home/rvm/
```

이 환경 변수들은 생성된 컨테이너에서 계속 유지된다.
환경 변수들을 -e 플래그를 사용하여 docker run 커맨드로 전달할 수도 있다. 

```
$ docker run -it -e "WEB_PORT=8080" ubuntu env
```

USER

USER명령어는 이미지를 실행시키는 사용자를 설정한다.

```
USER lee
```

이 명령어는 nginx 사용자에 의해 실행되는 이미지에서 컨테이너를 생성한다. 사용자 이름 혹은 UID를 설정한다. 
또한 런타임에 docker run 커맨드와 함께 -u 플래그를 설정해서 오버라이드 할 수 있다.

-> USER 명령어를 설정하지 않는다면 디폴트 사용자는 루트이다.

VOLUME

이미로부터 생성된 컨테이너에 볼륨을 추가한다. 볼륨은 유니온 파일 시스템을 바이패스하는 하나 이상의 컨테이너 안에서 특별히 설계된 디렉터리이다. 이 유니온 파일 시스템은 데이터를 유지하거나 공유하기 위해 몇 가지 유용한 기능을 제공한다. 

- 볼륨은 컨테이너 사이에서 공유되고 재사용된다.
- 컨테이너는 볼륨을 공유하기 위해 실행될 필요는 없다.
- 볼륨에 대한 변경은 직접 적용된다.
- 볼륨에 대한 변경은 이미지를 업데이트할 때는 포함되지 않는다
- 볼룸은 컨테이너가 사용하지 않을 때까지 계속 유지된다. 
-
이는 데이터, 데이터베잇, 혹은 다른 컨텐치를 이미지에 커밋하지 않고 이미지로 추가하게 해준다. 또한 컨테이너 간에 데이터를 공유할 수 있게 해준다. 이는 컨테이너와 애플리케이션 코드 관리로그 컨테이너 안의 데이터베이스 처리 등을 테스트 하는데 사용된다. 

```
VOLUME ["/opt/project"]
```

위의 명령어는 이미지로부터 생성한 컨테이너에 마운트를 생성한다. 또는 배열을 설정해서 여러 볼륨을 설정할 수 있다. 

```
VOLUME ["/opt/project", "/data"]
111
```

ADD

빌드환경에서 이미지로 파일과 디렉터리를 추가한다. 파일에 대한 소스와 목적지를 설정한다. 

```
ADD software.lic /opt/application/sortware.lic
```

이 명령어는 빌드 디렉터리에서 이미지의 /opt/application/software.lic로 software.lic 파일을 복사한다 파일의 소스 URL, 파일 이름 혹은 디렉터리가 된다. 파일이나 디렉터리는 빌드 디렉터리에 상대적 경로로 설정해야 한다. 예를 들면 다음과 같다. 

```
ADD ../app/opt/
```

이 명령어는 빌드 디렉터리 위에 있는 디렉터리인 app디렉터리를 /opt/ 디렉터리로 재귀적으로 복사한다. 도커는 소스(파일인지 디렉토리인지)가 무엇인지 결정하기 위해 목적지의 마지막 문자를 사용한다. 목적지가 /로 끄나면 디렉터리를 의미한다. /가 없으면 소스가 파일이라는 것을 의미한다. 또한 url이 될 수 있다. 

```
ADD http://... /root/wordpress.zip
```

마지막으로 ADD 명령어는 몇 가지 특별한 기능이 있는데 로컬 tar 압축 파일을 처리할 수 있다는 점이다. tar압축 파일이 소스 파일로 설정되며 도커는 자동으로 이 압축 파일을 해제한다. 

```
ADD latest.tar.gz /var/www/wordress/
```

위 명령어는 latest.tar.gz 압축 파일을 /var/www/wordpress/ 디렉터리에 해제한다. 압축 파일은 -x 옵션을 사용한 tar를 실행시킨 것과 같은 동작을 한다. 결과물은 압축 파일의 내용이 된다. 목적 디렉터리 내에 같은 이름을 갖는 파일이나 디렉터리가 존재하면 덮어쓰지는 않는다. 

> 현재 이 기능은 URL에서 설정한 tar 압축 파일에는 동작하지 않는다. 현재는 다소 불완전한 동작을 보여주고 있지만 향후 릴리즈에서는 변경될 것이다. 

마지막으로 목적지가 존재하지 않으면 도커는 디렉터리를 포함한 전체 경로를 생성한다. 새로운 파일과 디렉토리는 0755 모드로 생성되며 UID 와 GID는 0으로 생성된다.

COPY

ADD명령어와 차이점은 COPY명령어는 빌드 컨텍스트에서 로컬 파일을 복사하는 작업에 초점을 맞추며 추출이나 압축 해제와 같은 기능은 갖고 있지 않다는 점이다. 

```
COPY conf.d/ /etc/apache2
```

위 작업은 conf.d 디렉터리로부터 파일을 /etc/apache2/ 디렉터리로 복사한다. 파일의 소스는 빌드 컨텍스트에 상대적인 디렉터리나 파일의 경로가 되어야 한다. 또한 빌드 컨텍스트는 Dockerfile이 존재하는 위치의 로컬 소스 디렉터리이다. 이 디렉터리 밖에 있는 것은 복사할 수 없다. 그 이유는 빌드 컨텍스트는 도커 데몬에 업로드되며 복사도 그 데몬에서 실행되기 때문이다. 빌드 컨텍스트 밖의 파일이나 디렉터리는 사용이 불가능하다. 목적지는 컨테이너 내부에 있는 절대 경로가 되어야 한다. 

복사를 해서 생성한 파일이나 디렉터리는 UID와 GID를 0으로 갖게 된다. 소스가 디렉터리면 전체 디렉터리가 복사되며 이 디렉터리는 파일시스템의 메타 데이터도 포함한다. 소스가 파일 종류라면 그 파일의 메타 데이터와 함께 개별적으로 복사된다.

ONBUILD

이미지에 트리거를 추가한다. 트리거는 이미지가 다른 이미지의 베이스로 사용될 때 실행된다. 트리거는 새로운 명령어가 FROM명령어 다음에 위치하도록 설정하는 것처럼 새로운 명령어를 빌드 과정에 삽입한다. 트리거는 어떤 빌드 명령어도 될 수 있다.

```
ONBUILD ADD . /app/src
```

이것은 ONBUILD 트리거를 생성한 이미지에 추가하고 이미지에서 docker inspect 커맨드를 실행할 때 볼 수 있다. 

원본 이미지를 상속받은 자식 이미지에서 이미지를 빌드 시 순서는 자식 이미지 FROM -> 부모 이미지의 ONBUILD -> 부모 이미지의 MAINTAINER 부터 밑으로 시작함 

이런 방식은 유용한 템플릿 이미지가 된다. 

ONBUILD 트리거는 부모 이미지에 설정된 순서에 따라 실행되며 한번은 상속할 수 있다. (자식은 되지만 손자는 될 수 없다.) 트리거는 손자 이미지를 빌드했을 때는 실행되지 않는다. 

> ONBUILD에서도 FROM, MAINTAINTER그리고 ONBUILD는 사용할 수 없다. 



