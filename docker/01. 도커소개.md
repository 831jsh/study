도커 소개
=========

컴퓨터 분야에서 컨테이너라는 개념은 오랜 역사를 갖고 있다. 하나 이상의 독립적인 머신이 중개 레이어(intermediation)를 통해 물리적 하드웨어에서 가상으로 동작하는 하이퍼바이저 가상화와는 달리 컨테이너는 운영체제의 커널 위에 존재하는 사용자 공간(user space)에서 동작한다.

따라서 컨테이너 가상화를 종종 운영체제 레벨 가상화라고 부르기도 한다. 컨테이너 기술을 사용하면 여러 개의 독립된 사용자 공간 인스턴스를 하나의 호스트에서 사용할 수 있다.

컨테이너를 사용하는 방식이 하이퍼바이저를 사용할 때만큼 완전히 독립적인 형태의 보안성을 제공하지는 못하다고 알려졌다. 이러한 주장에 대한 반박으로 경량화되어 있는 컨테이너의 개념을 사용하면 어느 정도는 보안 위험성을 감소시킬 수 있다.
그 이유는 가상 머신에서 하이퍼바이저를 사용하게 되면 하이퍼바이저 위에 운영체제가 모두 탑재되어야 하며 따라서 운영체제에 대한 공격을 막는 방법이 필요하다. 반면에 경량화된 컨테이너를 사용하면 운영체제 전체가 필요한 것이 아니라 컨테이너 내부에서 사용되는 극히 일부의 운영체제 기능만 필요하기 때문에 상대적으로 공격 위험에 대한 노출이 적다고 볼 수있다. 

이러한 제약에도 불구하고 컨테이너는 다양한 사용자 케이스 형태로 배포되고 적용되어 오고 있다. 다중 임대 서비스의 하이퍼스케일을 배포하는 경우, 경량화 샌드박싱, 그리고 보안성 문제에도 불구하고 프로세스 고립 환경에서 많이 사용된다. 실제 컨테이너의 가장 대중적인 예는 chroot jail 방법이다. 이 방법을 사용하면 프로세스들을 실행하기 위해 고립된 디렉터리 환경을 생성한다. 공격자가 고립된 디렉터리 위치가 아닌 다른 디렉터리 위치에 접근하여 프로세스를 실행시키려고 하면 이 환경에 갇히게 되고 더 나아가 호스트와 연동할 수가 없게 된다.

더 현대적인 컨테이너 기술은 OpenVZ, 솔라리스 Zones, lxc와 같은 리눅스 컨테이너를 포함하고 있다. 이러한 최신 기술들을 사용하면 컨테이너는 단순 실행 환경이라기보다 마치 스스로가 권한을 갖고 있는 완전한 기능의 호스트처럼 보이게 된다. 도커의 경우 그룹이나 네임스페이스를 제어하는 등의 현대 리눅스 커널의 기능을 갖고 있으며 이것은 컨테이너가 하나의 호스트에서 여러 컨테이너들이 동시에 존재할 수 있도록 해주는 리소스 관리 기능 뿐만 아니라 독립적인 자신만의 네트워크나 스토리지 스택과 같은 강력한 고립 기능을 갖는 다는 것을 의미한다. 

컨테이너는 일반적으로 제한된 오버헤드만을 허용하기 때문에 린 기술을 고려하고 있다. 전통적인 가상화 혹은 반가상화 기술과는 달리 컨트롤러를 실행하기 위한 에뮬레이션 레이어나 하이퍼바이저 레이어가 필요 없으며 대신에 운영체제의 일반적인 시스템 콜 인터페이스를 사용한다. 이것은 컨테이너를 실행할 때 요구되는 오버헤드를 줄여주고 하나의 호스트에서 더 많은 컨테이너들이 동작하도록 해준다. 

컨테이너의 역사에 비해 컨테이너의 활용도를 보면 대규모 시스템에는 적용되지 못 해왔다. 이렇게 된 주된 이유 중 하나는 컨테이너의 복잡도에 있다. 컨테이너가 복잡해지고 셋업이 어려우며 관리와 자동화가 어렵다. 도커의 목적은 이러한 제약을 해결하는 데 있다. 

### 도커 소개

도커는 컨테이너 안에 있는 애플리케이션 배포를 자동화하는 오픈 소스 엔진이다.
Docker Inc팀이 개발했으며 아파치 라이선스 2.0으로 릴리즈 했다. 

**실제 상황을 모델링하기 위한 쉽고 경량화된 방법**

도커는 빠르다 단지 몇 분만에 애플리케이션을 도커화할 수 있다. 도커는 COW모델이어서 애플리케이션이 수정되어도 빠르게 대응할 수 있다. 수정된 부분만 변경되어 적용되도록 할 수가 있다.

하이퍼바이저의 오버헤드를 제거하는 것은 또한 컨테이너가 뛰어난 성능을 갖고 있다는 것을 의미하며 여러분은 더 많은 컨테이너를 호스트에 모을 수 있고 호스트에서 제공하는 리소스를 최적으로 사용할 수 있다는 것을 의미한다. 

**의무의 논리적 분리**

도커를 사용하면 개발자는 컨테이너 내부에서 동작하는 애플리케이션에 집중하고 오퍼레이션은 컨테이너를 관리하는 데 집중하게 된다. 도커는 개발자가 코드를 작성할 때의 환경과 개발한 애플리케이션이 배포되어 실행되는 환경을 보장하여 일관성을 향상시키도록 설계됐다. 이것은 개발할 때는 제대로 동작했는데 막상 실행해보니 문제가 발생한다와 같은 위험요소를 줄여준다. 

**빠르고 효율적인 개발 라이프사이클**

도커를 사용하는 목적은 코드를 작성하고 테스트하며 배포해서 사용되기까지의 개발 라이프 사이클에 걸리는 시간을 줄이는 데 있다. 애플리케이션이 포터블하고 빌드하기 쉬우며 여러 환경에서 협력하기 쉽도록 하는 것이 목적이다. 

### 도커 컴포넌트 

**도커 클라이언트와 서버**

도커는 클라이언트-서버 애플리케이션이다. 도커 클라이언는 도커 서버 혹은 데몬과 통신하며 교대로 작업한다. 도커에는 바이너리로 제공되는 커맨드 라인 클라이언트 바이너리인 docker와 소스 코드 내에서 도커를 사용할 수 있는 API를 제공한다.

**도커 이미지**

이미지는 도커 세계의 빌딩 블럭이다. 이미지에서 컨테이너를 런칭한다. 이미지는 도커의 라이프 사이클에서 빌드 파트에 해당한다. 도커 이미지는 여러 레이어로 나뉜 형태로 되어 있고 유니온 파일 시스템을 사용하며 명령어들이 단계별로 구축되어 있다. 

**레지스트리**

도커는 여러분이 구축한 이미지를 레지스트리에 저장한다. 두 가지 타입의 레지스트리가 있다. 하나는 퍼블릿이고 다른 하나는 프라이빗이다. 이 레지스트리를 도커 허브라고 부른다. 도커 허브에서 자신의 계정을 생성하고 도커 허브를 통해 여러분이 만든 이미지를 공유하거나 저장한다. 

**컨테이너**

도커는 개발한 애플리케이션과 서비스를 패키징하여 배포할 수 있도록 컨테이너를 구축하는 데 도움을 준다. 앞에서 언급한 대로 컨테이너는 이미지에서 런칭되고 하나 이상의 동작하는 프로세스를 포함할 수 있다. 도커 측면에서 보면 원하는 기능이 구현되어 있거나 패키징되어 있는 이미지로서의 컨테이너와 실제 기능이 실행되는 이미지로서의 컨테이너로 나눠 생각해볼 수 있다.

### 도커의 설정 관리

도커가 발표되고 puppet과 chef와 같은 설정 관리 툴 중에 어느 툴이 도커에 적합한지에 대해 많은 논의가 있었다. 도커는 이미지 구축과 이미지 관리 솔루션을 포함한다. 현재의 설정 관리 툴에서 제공해야 하는 기능 중 하나는 골든 이미지 모델에 대한 관리툴을 제공하는가 하는 점이다. 골든 이미지를 사용하면 결국 규모가 너무 커져서 관리가 불가능한 이미지들을 다루어야 한다. 이러한 이미지들은 다양한 버전에 따라 배포된 다수의 복잡한 이미지를 의미한다. 여러분이 사용하는 이미지가 점점 많아질수록 무작위성 혹은 불확실성은 높아져만 간다. 이러한 이미지는 또한 매우 헤비하고 다루기가 어려운 경향이 있다. 수작업으로 하는 변경 혹은 다양한 종류의 차이점, 그리고 이미지에 대한 관리되지 않는 설정등이 원인이 된다. 근본적으로 이러한 이미지는 유연성이 부족하기 때문이다. 

전통적인 이미지 모델과 비교해보면 도커는 훨씬 더 경량화되어 있다. 레이어 단위로 이미지들을 나누고 레이어로 된 이미지들을 빠르게 반복하여 액세스할 수 있다. 이러한 속성이 기존의 이미지에 존재하는 관리 문제 중 많은 부분을 해결할 수 있다는 점에 대해서는 논쟁의 여지는 있다. 이러한 기능이 모든 설정 관리 툴을 교체하거나 대체하도록 할 수 있다고 말하기는 아직까지 확실하지 않다. 그러나 설정 관리 툴이 제공하는 다양한 기능을 통해 놀라운 성능과 제어를 얻을 수 있다. 도커 자체는 여전히 호스트에 인스톨돼야 하고 호스트 내에서 관리돼야 하며 호스트단위로 배포돼야 한다. 

도커가 설치된 호스트도 잘 관리되어야 한다. 호스트에 설치된 도커 컨테이너를 잘 조직화하고 관리하며 필요헤 따라 적절하게 배포해야 한다. 종종 외부 서비스나 툴과 연동할 수도 있다. 도커 컨테이너와 연동하는 설정 관리 툴은 우수한 기능을 제공한다. 

**도커는 기존에 사용하던 방법과는 호스트 애플리케이션 그리고 서비스에 대해 다른 특징과 아키텍처를 갖고 있고 도커만의 방법을 사용하도록 강조한다. 그 이유는 도커에서 강조하는 방법은 짧은 수명, 불변성, 일회성 및 서비스 지향적이기 때문이다. 이러한 특징은 설정 관리 툴이 그다지 필요지 않은 것처럼 느껴질 수도 있다. 이러한 특징을 사용하게 되면 굳이 오랜 시간 동안 지속하는 관리에 대해서는 거의 고려하지 않게 되며 컨테이너가 그렇게 관리되어야 할만큼 오랫동안 존속되지 않기 때문에 불확실성은 거의 존재하지 않는다. 기존의 상태를 수정해 나가면서 유지하는 것보다 필요할 때마다 새롭게 생성하는 것이 훨씬 효율적일 수 있다.** 


### 
